#ifndef C_FLIR_ONE_RECEIVER_H
#define C_FLIR_ONE_RECEIVER_H

//****************************************************************************************************
//Класс приёма данных от Flir One
//****************************************************************************************************

//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************
#include <stdint.h>
#include <vector>
#include <string>
#include <memory>
#include "cringbuffer.h"

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//предварительные объявления
//****************************************************************************************************

//****************************************************************************************************
//Класс приёма данных от Flir One
//****************************************************************************************************
class CFlirOneReceiver
{
 public:
  //-перечисления---------------------------------------------------------------------------------------
  //-структуры------------------------------------------------------------------------------------------
  //-константы------------------------------------------------------------------------------------------

  //размер буфера приёма данных
  static const int32_t IMAGE_BUFFER_SIZE=1048576;

  //исходные размеры изображения (не перевёрнутые)
  static const int32_t ORIGINAL_IMAGE_WIDTH=160;
  static const int32_t ORIGINAL_IMAGE_HEIGHT=120;

  //исходные размеры видео (не перевёрнутые)
  static const int32_t ORIGINAL_VIDEO_WIDTH=640;
  static const int32_t ORIGINAL_VIDEO_HEIGHT=480;

  //размеры изображения после обработки и переворота в вертикальное положение
  static const int32_t IMAGE_WIDTH=120;
  static const int32_t IMAGE_HEIGHT=160;

  //размеры видео после обработки
  static const int32_t VIDEO_WIDTH=480;
  static const int32_t VIDEO_HEIGHT=640;

  //размер изображений
  static const int32_t THERMAL_IMAGE_SIZE=(IMAGE_WIDTH*IMAGE_HEIGHT);
  static const int32_t COLOR_IMAGE_SIZE=(IMAGE_WIDTH*IMAGE_HEIGHT);
  static const int32_t VIDEO_IMAGE_SIZE=(VIDEO_WIDTH*VIDEO_HEIGHT);

  static const int32_t COLOR_MAP_UNIT=256;//количество цветов в палитре
  static const int32_t COLOR_SIZE=3;//число байт на один цвет (RGB)
  static const int32_t MAX_COLOR_INDEX=(COLOR_MAP_UNIT-1);//максимальный индекс цвета
 private:
  //-структуры------------------------------------------------------------------------------------------

  #pragma pack(1)
  //заголовок кадра тепловизора
  struct SHeader
  {
   uint8_t MagicByte[4];//магические байты
   uint8_t Unknow1[4];//неизвестные данные
   uint32_t FrameSize;//полный размер кадра
   uint32_t ThermalSize;//размер кадра тепловизора
   uint32_t JpgSize;//размер изображения с камеры
   uint32_t StatusSize;//размер слова состояния
   uint8_t Unknow2[4];//неизвестные данные
  };
  #pragma pack()

  //-переменные-----------------------------------------------------------------------------------------

  //палитра перекодировки изображения
  uint8_t ColorMap_R[COLOR_MAP_UNIT];
  uint8_t ColorMap_G[COLOR_MAP_UNIT];
  uint8_t ColorMap_B[COLOR_MAP_UNIT];

  std::unique_ptr<CRingBuffer> cRingBuffer_Ptr;//кольцевой буфер приёма данных

  SHeader sHeader;//заголовок пакета
  bool HeaderIsReceived;//заголовок принят

  uint8_t MagicPos;//позиция анализируемого магического байта
  uint32_t MagicHeadPos;//позиция головы, когда встречился первый магический байт

  std::vector<uint16_t> ThermalImage;//тепловое изображение (raw14)
  std::vector<uint32_t> VideoImage;//изображение с видеокамеры
  std::vector<uint32_t> ColorImage;//раскрашенное изображение

  std::vector<uint8_t> JPGImage;//прямые данные с видеокамеры (картинка в jpg)

  long FrameIndex;//номер текущего кадра

  bool ShowVideo;//показывать ли видео
 public:
  //-конструктор----------------------------------------------------------------------------------------
  CFlirOneReceiver(void);
  //-деструктор-----------------------------------------------------------------------------------------
  ~CFlirOneReceiver();
 public:
  //-открытые функции-----------------------------------------------------------------------------------
  bool LoadColorMap(const std::string &filename);//загрузить карту перекодировки изображения
  bool CopyColorImage(std::vector<uint32_t> &image,uint32_t &index);//скопировать раскрашенное изображение в буфер
  bool CopyThermalImage(std::vector<uint16_t> &image,uint32_t &index);//скопировать тепловое изображение в буфер
  bool CopyVideoImage(std::vector<uint32_t> &image,uint32_t &index);//скопировать изображение с видеокамеры в буфер
  bool CopyJPGImage(std::vector<uint8_t> &vector_jpg,uint32_t &index);//скопировать данные с видеокамеры в буфер
  bool CopyColorMap(uint8_t R[COLOR_MAP_UNIT],uint8_t G[COLOR_MAP_UNIT],uint8_t B[COLOR_MAP_UNIT],uint32_t size);//скопировать палитру
  bool CreateImage(uint8_t *buffer,uint32_t size);//создать изображение
  void SetShowVideo(bool state);//показывать ли видео
 private:
  //-закрытые функции-----------------------------------------------------------------------------------  
  void CalculateCRC(uint16_t &crc,uint8_t byte);//вычислить crc
};

#endif
